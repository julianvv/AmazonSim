<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Amazon Simulatie</title>
    <link rel="stylesheet" href="./css/style.css">

</head>

<body style="margin:0px;padding:0px;overflow:hidden;">
    <!--
        Deze pagina is de standaardpagina van de client. Hierin wordt de 3D wereld opgezet en wordt geluisterd
        naar updates vanaf de server over de websocket communicatie.
    -->
    <script type="module">
    import * as THREE from "./three/build/three.module.js";
    import { OrbitControls } from "./three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from './three/examples/jsm/loaders/GLTFLoader.js';
    import {EffectComposer} from "./three/examples/jsm/postprocessing/EffectComposer.js ";
    import {BloomPass} from "./three/examples/jsm/postprocessing/BloomPass.js";
    import {RenderPass} from "./three/examples/jsm/postprocessing/RenderPass.js";
    import {FilmPass} from "./three/examples/jsm/postprocessing/FilmPass.js";
    import { nodegrid } from "./nodeGrid.js";
    import { Gui, addOption, addAnimation, getCurrentCamera } from "./gui/gui.js";

    let cameraControls, camera, currentCamera, closeGarage, gui, mixer, mixer2, openGarage, renderer, scene, socket, warehouseObject;
    const gltfLoader = new GLTFLoader();

    function parseCommand(input = "") {
        console.log(JSON.parse(input));
        return JSON.parse(input);
    }

    window.onload = function () {
        let worldObjects = {};

        function init() {
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.x = 15;
            camera.position.y = 5;
            camera.position.z = 15;

            scene = new THREE.Scene();

            const cubeLoader = new THREE.CubeTextureLoader();
            const sbTextureDay = cubeLoader.load([
            './textures/Skybox/side.png',
            './textures/Skybox/side.png',
            './textures/Skybox/top.png',
            './textures/Skybox/bottom.png',
            './textures/Skybox/side.png',
            './textures/Skybox/side.png'
            ]);
            scene.background = sbTextureDay;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight + 5);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMapEnabled = true;
            renderer.shadowMapType = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            cameraControls = new OrbitControls(camera, renderer.domElement);
            cameraControls.update();

            let directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
            directionalLight.position.set(-150, 500, -50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            gui = new Gui(scene, directionalLight, camera, cameraControls);

            let pointLight = new THREE.PointLight(0xFFFFFF, 1, 100, 2);
            pointLight.position.set(-40, 20, 10);
            pointLight.castShadow = true;
            pointLight.shadow.normalBias = 0.1;
            scene.add(pointLight);

            let light = new THREE.AmbientLight(0x404040);
            light.intensity = 2;
            scene.add(light);
        }

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }



        let then = 0;
        function render(now) {
            now *= 0.001;
            let deltaTime = now - then;
            then = now;
            camera.updateProjectionMatrix();
            currentCamera = getCurrentCamera();

            if(mixer != null){
                mixer.update(deltaTime);
            }

            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                composer.setSize(canvas.width, canvas.height);
                renderer.setSize(canvas.width, canvas.height);
            }

            if (currentCamera == "free"){
                renderer.render(scene, camera);
            }
            else{
                composer.render(deltaTime);
            }
            requestAnimationFrame(render);
        }

        /*
         * Hier wordt de socketcommunicatie geregeld. Er wordt een nieuwe websocket aangemaakt voor het webadres dat we in
         * de server geconfigureerd hebben als connectiepunt (/connectToSimulation). Op de socket wordt een .onmessage
         * functie geregistreerd waarmee binnenkomende berichten worden afgehandeld.
         */
        socket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connectToSimulation");
        socket.onmessage = function (event) {
            //Hier wordt het commando dat vanuit de server wordt gegeven uit elkaar gehaald
            let command = parseCommand(event.data);

            //Wanneer het commando is "object_update", dan wordt deze code uitgevoerd. Bekijk ook de servercode om dit goed te begrijpen.
            if (command.command == "object_update") {
                //Wanneer het object dat moet worden geupdate nog niet bestaat (komt niet voor in de lijst met worldObjects op de client),
                //dan wordt het 3D model eerst aangemaakt in de 3D wereld.
                if (Object.keys(worldObjects).indexOf(command.parameters.uuid) < 0) {

                    if (command.parameters.type == "building") {
                        worldObjects[command.parameters.uuid] = null;
                        gltfLoader.load('./gltf/amazonmapV4.glb', function ( gltf ) {
                            let warehouse = gltf.scene;
                            warehouse.scale.set(50,50,50);
                            console.log(warehouse);

                            warehouse.position.set(command.parameters.x, command.parameters.y, command.parameters.z);

                            mixer = new THREE.AnimationMixer(warehouse);
                            let clip1 = gltf.animations[1];
                            openGarage = mixer.clipAction(clip1);
                            openGarage.loop = THREE.LoopOnce;
                            openGarage.clampWhenFinished = true;

                            mixer2 = new THREE.AnimationMixer(warehouse);
                            let clip2 = gltf.animations[0];
                            closeGarage = mixer.clipAction(clip2);
                            closeGarage.loop = THREE.LoopOnce;
                            closeGarage.clampWhenFinished = true;

                            warehouse.traverse( function (node){
                                    node.castShadow = true;
                                    node.receiveShadow = true;
                            });

                            warehouseObject = {
                                warehouse: warehouse,
                                ceilingStatus: warehouse.children[3].visible
                            }

                            addOption(warehouseObject, 'ceilingStatus').name('Ceiling').onChange(function (){
                                if(warehouseObject.warehouse.children[3].visible){
                                    warehouseObject.warehouse.children[3].visible = false;
                                    console.log('ceiling becomes false');
                                }else{
                                    warehouseObject.warehouse.children[3].visible = true;
                                    console.log('ceiling becomes true');
                                }
                            });
                            scene.add(warehouse);
                            console.log(warehouse);
                            worldObjects[command.parameters.uuid] = warehouse;

                            let garageObj = {
                                open: function (){
                                    openGarage.play();
                                },
                                close: function (){
                                    closeGarage.play();
                                }
                            }
                            addAnimation(garageObj, 'open').name("Open");
                            addAnimation(garageObj, 'close').name("Close");
                        });
                    }
                    //Wanneer het object een robot is, wordt de code hieronder uitgevoerd.
                    if (command.parameters.type == "robot") {
                        let geometry = new THREE.BoxGeometry(0.9, 0.3, 0.9);
                        let cubeMaterials = [
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_side.png"), side: THREE.DoubleSide }), //LEFT
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_side.png"), side: THREE.DoubleSide }), //RIGHT
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_top.png"), side: THREE.DoubleSide }), //TOP
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_bottom.png"), side: THREE.DoubleSide }), //BOTTOM
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_front.png"), side: THREE.DoubleSide }), //FRONT
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_front.png"), side: THREE.DoubleSide }), //BACK
                        ];

                        let robot = new THREE.Mesh(geometry, cubeMaterials);
                        robot.receiveShadow = true;
                        robot.castShadow = true;
                        robot.position.set(command.parameters.x, command.parameters.y, command.parameters.z);

                        scene.add(robot);
                        worldObjects[command.parameters.uuid] = robot;
                    }

                    if (command.parameters.type == "truck") {
                        worldObjects[command.parameters.uuid] = null;
                        gltfLoader.load('./gltf/AmazonTruck.glb', function (gltf){
                            let truck = gltf.scene;
                            truck.scale.set(2,2,2);
                            truck.traverse( function (node){
                                node.castShadow = true;
                                node.receiveShadow = true;
                            });
                            truck.position.set(command.parameters.x, command.parameters.y, command.parameters.z);
                            scene.add(truck);
                            worldObjects[command.parameters.uuid] = truck;
                        });
                    }

                    if (command.parameters.type == "stellage") {
                        worldObjects[command.parameters.uuid] = null;
                        gltfLoader.load('./gltf/stellage.glb', function (gltf){
                           let stellage = gltf.scene;

                           stellage.traverse( function (node){
                               node.castShadow = true;
                               node.receiveShadow = true;
                           });
                           stellage.position.set(command.parameters.x, command.parameters.y, command.parameters.z);
                           scene.add(stellage);
                           worldObjects[command.parameters.uuid] = stellage;
                        });
                    }
                }

                /*
                 * Deze code wordt elke update uitgevoerd. Het update alle positiegegevens van het 3D object.
                 */
                let object = worldObjects[command.parameters.uuid];

                if(object != null){
                object.position.x = command.parameters.x;
                object.position.y = command.parameters.y;
                object.position.z = command.parameters.z;

                object.rotation.x = command.parameters.rotationX;
                object.rotation.y = command.parameters.rotationY;
                object.rotation.z = command.parameters.rotationZ;
                }
            }
        }

        init();

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene,camera));
        const bloomPass = new BloomPass(
            1,    // strength
            10,   // kernel size
            1,    // sigma ?
            1024,  // blur render target resolution
        );
        composer.addPass(bloomPass);

        const filmPass = new FilmPass(
            1,   // noise intensity
            0.2,  // scanline intensity
            400,    // scanline count
            true,  // grayscale
        );
        filmPass.renderToScreen = true;
        composer.addPass(filmPass);

        render();

        let columns = 2;
        let rows = 174;
        let nodesize = 0.5;
        let originx = -90;
        let originz = 8;
        nodegrid(columns, rows, nodesize,originx,originz, scene);
    }

    </script>
</body>

</html>