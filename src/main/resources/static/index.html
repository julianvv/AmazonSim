<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Amazon Simulatie</title>
    <link rel="stylesheet" href="./css/style.css">

</head>

<body style="margin:0px;padding:0px;overflow:hidden;">
    <!--
        Deze pagina is de standaardpagina van de client. Hierin wordt de 3D wereld opgezet en wordt geluisterd
        naar updates vanaf de server over de websocket communicatie.
    -->
    <script type="module">
    import * as THREE from "./three/build/three.module.js";
    import { OrbitControls } from "./three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from './three/examples/jsm/loaders/GLTFLoader.js';
    import { GUI } from './three/examples/jsm/libs/dat.gui.module.js';
    import {EffectComposer} from "./three/examples/jsm/postprocessing/EffectComposer.js ";
    import {BloomPass} from "./three/examples/jsm/postprocessing/BloomPass.js";
    import {RenderPass} from "./three/examples/jsm/postprocessing/RenderPass.js";
    import {FilmPass} from "./three/examples/jsm/postprocessing/FilmPass.js";
    import { saveCameraLocation } from "./saveLoadCamera.js";
    import { loadCameraLocation } from "./saveLoadCamera.js";
    import { nodegrid } from "./nodeGrid.js";

    let cameraControls, camera;
    let scene, renderer;
    let currentCamera = "free";
    let warehouseObject, mixer, openGarage;
    const gui = new GUI();
    const animations = gui.addFolder('Animations');
    const cameras = gui.addFolder('Camera\'s');
    const options = gui.addFolder('Options');

    const gltfLoader = new GLTFLoader();

    let socket;

    function parseCommand(input = "") {
        return JSON.parse(input);
    }

    window.onload = function () {
        let worldObjects = {};

        function init() {
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.x = 15;
            camera.position.y = 5;
            camera.position.z = 15;

            scene = new THREE.Scene();

            const cubeLoader = new THREE.CubeTextureLoader();
            const sbTextureDay = cubeLoader.load([
            './textures/Skybox/side.png',
            './textures/Skybox/side.png',
            './textures/Skybox/top.png',
            './textures/Skybox/bottom.png',
            './textures/Skybox/side.png',
            './textures/Skybox/side.png'
            ]);
            const sbTextureNight = cubeLoader.load([
                './textures/Skybox/sideN.png',
                './textures/Skybox/sideN.png',
                './textures/Skybox/topN.png',
                './textures/Skybox/bottomN.png',
                './textures/Skybox/sideN.png',
                './textures/Skybox/sideN.png'
            ]);

            scene.background = sbTextureDay;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight + 5);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMapEnabled = true;
            renderer.shadowMapType = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            cameraControls = new OrbitControls(camera, renderer.domElement);
            cameraControls.update();

            let directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
            directionalLight.position.set(-150, 500, -50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            let dayObj = {
                name: 'Dag',
                day: true
            }
            options.add(dayObj, 'day').name(dayObj.name).onChange(function (){
                if(dayObj.day === false){
                    directionalLight.color.set(0xFFF);
                    scene.background = sbTextureNight;
                }else{
                    directionalLight.color.set(0xFFFFFF);
                    scene.background = sbTextureDay;
                }
            });

            let hemiLight = new THREE.HemisphereLight( 0xFF38D7, 0xFFA851, 0.2 );
            //scene.add(hemiLight);

            let light = new THREE.AmbientLight(0x404040);
            light.intensity = 2;
            scene.add(light);
        }

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }



        let then = 0;
        function render(now) {
            now *= 0.001;
            let deltaTime = now - then;
            then = now;
            camera.updateProjectionMatrix();

            if(mixer != null){
                mixer.update(deltaTime);
            }

            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                composer.setSize(canvas.width, canvas.height);
                renderer.setSize(canvas.width, canvas.height);
            }

            if (currentCamera == "free"){
                renderer.render(scene, camera);
            }
            else{
                composer.render(deltaTime);
            }
            requestAnimationFrame(render);
        }

        /*
         * Hier wordt de socketcommunicatie geregeld. Er wordt een nieuwe websocket aangemaakt voor het webadres dat we in
         * de server geconfigureerd hebben als connectiepunt (/connectToSimulation). Op de socket wordt een .onmessage
         * functie geregistreerd waarmee binnenkomende berichten worden afgehandeld.
         */
        socket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connectToSimulation");
        socket.onmessage = function (event) {
            //Hier wordt het commando dat vanuit de server wordt gegeven uit elkaar gehaald
            let command = parseCommand(event.data);

            //Wanneer het commando is "object_update", dan wordt deze code uitgevoerd. Bekijk ook de servercode om dit goed te begrijpen.
            if (command.command == "object_update") {
                //Wanneer het object dat moet worden geupdate nog niet bestaat (komt niet voor in de lijst met worldObjects op de client),
                //dan wordt het 3D model eerst aangemaakt in de 3D wereld.
                if (Object.keys(worldObjects).indexOf(command.parameters.uuid) < 0) {

                    if (command.parameters.type == "building") {
                        worldObjects[command.parameters.uuid] = null;
                        gltfLoader.load('./gltf/amazonmap.glb', function ( gltf ) {
                            let warehouse = gltf.scene;
                            warehouse.scale.set(50,50,50);

                            mixer = new THREE.AnimationMixer(warehouse);
                            let clip1 = gltf.animations[0];
                            openGarage = mixer.clipAction(clip1);
                            openGarage.loop = THREE.LoopOnce;
                            openGarage.clampWhenFinished = true;

                            warehouse.traverse( function (node){
                                    node.castShadow = true;
                                    node.receiveShadow = true;
                            });

                            warehouseObject = {
                                warehouse: warehouse,
                                ceilingStatus: warehouse.children[3].visible
                            }

                            options.add(warehouseObject, 'ceilingStatus').name('Ceiling').onChange(function (){
                                if(warehouseObject.warehouse.children[3].visible){
                                    warehouseObject.warehouse.children[3].visible = false;
                                    console.log('ceiling becomes false');
                                }else{
                                    warehouseObject.warehouse.children[3].visible = true;
                                    console.log('ceiling becomes true');
                                }
                            });
                            scene.add(warehouse);
                            console.log(warehouse);
                            worldObjects[command.parameters.uuid] = warehouse;

                            let garageObj = {
                                open: function (){
                                    openGarage.play();
                                },
                                close: function (){
                                    openGarage.play();
                                }
                            }
                            animations.add(garageObj, 'open').name("Open");
                            animations.add(garageObj, 'close').name("Close");
                        });
                    }
                    //Wanneer het object een robot is, wordt de code hieronder uitgevoerd.
                    if (command.parameters.type == "robot") {
                        let geometry = new THREE.BoxGeometry(0.9, 0.3, 0.9);
                        let cubeMaterials = [
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_side.png"), side: THREE.DoubleSide }), //LEFT
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_side.png"), side: THREE.DoubleSide }), //RIGHT
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_top.png"), side: THREE.DoubleSide }), //TOP
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_bottom.png"), side: THREE.DoubleSide }), //BOTTOM
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_front.png"), side: THREE.DoubleSide }), //FRONT
                            new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/robot_front.png"), side: THREE.DoubleSide }), //BACK
                        ];

                        let robot = new THREE.Mesh(geometry, cubeMaterials);
                        robot.position.y = 0.15;
                        robot.receiveShadow = true;
                        robot.castShadow = true;
                        let group = new THREE.Group();
                        group.add(robot);

                        scene.add(group);
                        worldObjects[command.parameters.uuid] = group;
                    }

                    if (command.parameters.type == "truck") {
                        worldObjects[command.parameters.uuid] = null;
                        gltfLoader.load('./gltf/truck1.glb', function (gltf){
                            let truck = gltf.scene;
                            truck.scale.set(2,2,2);
                            truck.traverse( function (node){
                                node.castShadow = true;
                                node.receiveShadow = true;
                            });
                            scene.add(truck);
                            worldObjects[command.parameters.uuid] = truck;
                        });
                    }

                    if (command.parameters.type == "stellage") {
                        worldObjects[command.parameters.uuid] = null;
                        gltfLoader.load('./gltf/stellage.glb', function (gltf){
                           let stellage = gltf.scene;

                           stellage.traverse( function (node){
                               node.castShadow = true;
                               node.receiveShadow = true;
                           });
                           scene.add(stellage);
                           worldObjects[command.parameters.uuid] = stellage;
                        });
                    }
                }

                /*
                 * Deze code wordt elke update uitgevoerd. Het update alle positiegegevens van het 3D object.
                 */
                let object = worldObjects[command.parameters.uuid];

                if(object != null){
                object.position.x = command.parameters.x;
                object.position.y = command.parameters.y;
                object.position.z = command.parameters.z;

                object.rotation.x = command.parameters.rotationX;
                object.rotation.y = command.parameters.rotationY;
                object.rotation.z = command.parameters.rotationZ;
                }
            }
        }

        let cameraObject = {
            free: function (){
                cameraControls.enabled = true;
                if (currentCamera !== "free"){
                    currentCamera = "free";
                    loadCameraLocation(camera);
                }
                console.log("Changed camera to Free Cam.");
                },
            camera1: function (){
                if(currentCamera === "free"){
                    saveCameraLocation(camera);
                }
                cameraControls.enabled = false;
                camera.position.x = -89;
                camera.position.y = 20;
                camera.position.z = 130;
                camera.rotation.x = -(Math.PI * 2)/10;
                camera.rotation.y = -((Math.PI*2)/8);
                camera.rotation.z = -(Math.PI*2)/15;
                currentCamera = "cam1";
                console.log("Changed camera to Camera 1.");
            },
            camera2: function (){
                if(currentCamera === "free"){
                    saveCameraLocation(camera);
                }
                cameraControls.enabled = false;
                camera.position.x = -89;
                camera.position.y = 20;
                camera.position.z = -10;
                camera.rotation.x = -(Math.PI * 2)/10;
                camera.rotation.y = ((Math.PI*2)/8);
                camera.rotation.z = -(Math.PI*2)/15;
                currentCamera = "cam2";
                console.log("Changed camera to Camera 2.");
            },
            camera3: function (){
                if(currentCamera === "free"){
                    saveCameraLocation(camera);
                }
                cameraControls.enabled = false;
                camera.position.x = -89;
                camera.position.y = 20;
                camera.position.z = -10;
                camera.rotation.x = -(Math.PI * 2)/10;
                camera.rotation.y = -((Math.PI*2)/8);
                camera.rotation.z = -(Math.PI*2)/15;
                currentCamera = "cam3";
                console.log("Changed camera to Camera 3.");
            }
        }
        cameras.add(cameraObject, 'free').name('Free cam');
        cameras.add(cameraObject, 'camera1').name('Camera 1');
        cameras.add(cameraObject, 'camera2').name('Camera 2');
        cameras.add(cameraObject, 'camera3').name('Camera 3');

        init();

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene,camera));
        const bloomPass = new BloomPass(
            1,    // strength
            10,   // kernel size
            1,    // sigma ?
            1024,  // blur render target resolution
        );
        composer.addPass(bloomPass);

        const filmPass = new FilmPass(
            1,   // noise intensity
            0.2,  // scanline intensity
            400,    // scanline count
            true,  // grayscale
        );
        filmPass.renderToScreen = true;
        composer.addPass(filmPass);

        render();

        let columns = 10;
        let rows = 10;
        let nodesize = 0.5;
        let originx = 80;
        let originz = 125;
        nodegrid(columns, rows, nodesize,originx,originz, scene);
    }

    </script>
</body>

</html>